// Q1
// O(n) unordered, O(n^2) ordered

// Q2
// binary search, find where 0 and 1 separate, then count index

// Q3
// iterate through the entire collection, each new occurance to a
// new object is added to an array in a ordered manner
// if using linked list, this can be O(n) as we can append the
// new object orderly without sorting
// if using array, this will be O(nlgn) using the algorithm in class
// or O(n) using 'count sort'

// Q4
// n^2
// n^2

// Q5
// n^2

// Q6
// - using prime number as sizes
// - numbers are placed as far as from each other (spread evenly)
// - should fill up the sapce
// - 

// Q7

// Q8
// linear addressing can have too much items bunched up around the same area
// where quadratic spreads out by increasing index offset using polynomial

// Q9
